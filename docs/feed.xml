<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cisco China ADC Engineering Blog</title>
    <description>Cisco China ADC Engineering Blog.
</description>
    <link>http://ciscochina.github.io/engineering/</link>
    <atom:link href="http://ciscochina.github.io/engineering/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 17 Jan 2018 20:46:32 +0800</pubDate>
    <lastBuildDate>Wed, 17 Jan 2018 20:46:32 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Mariadb Installation &amp; Master-Master Replication</title>
        <description>&lt;p&gt;本文记录了MYSQL双主备份的配置过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;版本和安装&lt;/h2&gt;

&lt;h3 id=&quot;mariadb--1028&quot;&gt;1. 文档使用Mariadb 最新稳定版本 10.2.8&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[cisco@dev1 ~]$ mysql -V
mysql  Ver 15.1 Distrib 10.2.8-MariaDB, for Linux (x86_64) using  EditLine wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;​&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 安装教程&lt;/h3&gt;

&lt;p&gt;https://downloads.mariadb.org/mariadb/repositories/#mirror=neusoft&amp;amp;distro=CentOS&amp;amp;distro_release=centos7-amd64–centos7&amp;amp;version=10.2&lt;/p&gt;

&lt;h2 id=&quot;ha&quot;&gt;HA配置与部署&lt;/h2&gt;

&lt;p&gt;以下操作建议在数据库安装完毕、插入数据前进行，以避免出现问题&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1 编辑配置文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/my.cnf.d/server.cnf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编辑如下部分，注意2台设备的server-id和自增offset设置为不一致&lt;/p&gt;

&lt;p&gt;设备1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[mysqld]

log-bin=mysql-bin // Replication要求必须打开 bin log功能 
server-id=101      // 两台设备分别设置不同的 id
    ​

auto-increment-increment=2  //id自增间隔，设置成2 
auto-increment-offset=1         //其中一台设置为1，另外一台设置为2，这主要为了避免2台MySQL的id自增发生重复


replicate-do-db=demo     // 需要同步的数据库，多个数据库写多行
relay-log=mysqld-relay-bin
log-slave-updates 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;​设备2&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;​[mysqld]

log-bin=mysql-bin // Replication要求必须打开 bin log功能 
​server-id=102      // 两台设备分别设置不同的 id

​auto-increment-increment=2  //id自增间隔，设置成2 
​auto-increment-offset=2         //其中一台设置为1，另外一台设置为2，这主要为了避免2台MySQL的id自增	发生重复

​replicate-do-db=demo     // 需要同步的数据库，多个数据库写多行
​relay-log=mysqld-relay-bin
log-slave-updates 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置完两台server以后，分别启动mysql.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start mariadb.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果有防火墙，主要把mysql 3306端口配置成允许访问&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;firewall-cmd --zone=public --add-service=mysql --permanent
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;a-mysql-cli-master&quot;&gt;2 进入设备A 的MySQL CLI 进行本机Master角色配置&lt;/h3&gt;

&lt;p&gt;mysql shell配置：另外一台机器访问此master的权限，用户和密码以及以及所在的机器地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mysql 
&amp;gt; GRANT REPLICATION CLIENT, REPLICATION SLAVE ON *.* TO 'copyuser'@'172.16.1.%' IDENTIFIED BY 'root@123';
&amp;gt; FLUSH PRIVILEGES;
&amp;gt; SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql_bin.000001 |      497 |              |                  |
+------------------+----------+--------------+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bslave&quot;&gt;3 进入设备B配置slave&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mysql 
&amp;gt; CHANGE MASTER TO MASTER_USER='copyuser',MASTER_PASSWORD='root@123',MASTER_HOST='172.16.1.100',MASTER_PORT=3306,MASTER_LOG_FILE='mysql_bin.000001',MASTER_LOG_POS=497;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动slave&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; START SLAVE;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看slave的状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; show slave status\G; 验证slave状态,注意一下两行是否为Yes


Slave_IO_Running: Yes
Slave_SQL_Running: Yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4 把2，3的配置过程反过来再做一次&lt;/h3&gt;

&lt;p&gt;设备B&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; GRANT REPLICATION CLIENT, REPLICATION SLAVE ON *.* TO 'copyuser'@'172.16.1.%' IDENTIFIED BY 'root@123';
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; FLUSH PRIVILEGES
    -&amp;gt; ;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]&amp;gt; 
MariaDB [(none)]&amp;gt; show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 |      816 |              |                  |
+------------------+----------+--------------+------------------+
1 row in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设备A&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mysql 
&amp;gt; CHANGE MASTER TO MASTER_USER='copyuser',MASTER_PASSWORD='root@123',MASTER_HOST='172.16.1.200',MASTER_PORT=3306,MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=816;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动slave&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; START SLAVE;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看slave的状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; show slave status\G; 验证slave状态,注意一下两行是否为Yes


Slave_IO_Running: Yes
Slave_SQL_Running: Yes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;验证&lt;/h2&gt;

&lt;p&gt;先在设备A上create数据库demo&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; create database demo;
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后到设备B上查看，demo也会自动产生&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| demo               |
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.00 sec)

MariaDB [(none)]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在设备A的demo里创建一个table&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; use demo;
Database changed
MariaDB [demo]&amp;gt; CREATE TABLE student (id INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,Name CHAR(30));
Query OK, 0 rows affected (0.07 sec)

MariaDB [demo]&amp;gt; show columns from student;
+-------+------------------+------+-----+---------+----------------+
| Field | Type             | Null | Key | Default | Extra          |
+-------+------------------+------+-----+---------+----------------+
| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| Name  | char(30)         | YES  |     | NULL    |                |
+-------+------------------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

MariaDB [demo]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在设备B上也能看到这个table&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [(none)]&amp;gt; use demo;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [demo]&amp;gt; show tables;
+----------------+
| Tables_in_demo |
+----------------+
| student            |
+----------------+
1 row in set (0.00 sec)

MariaDB [demo]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在设备B上插入数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [demo]&amp;gt; INSERT INTO student (Name) VALUES ('stu1'),('stu2');
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

MariaDB [demo]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在设备A上能看到数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MariaDB [demo]&amp;gt; select * from student;
+----+------+
| id | Name |
+----+------+
|  2 | stu1 |
|  4 | stu2 |
+----+------+
2 rows in set (0.00 sec)

MariaDB [demo]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/database/2018/01/16/mysql-replica.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/database/2018/01/16/mysql-replica.html</guid>
        
        
        <category>database</category>
        
      </item>
    
      <item>
        <title>virtualenvwrapper vs Pipenv</title>
        <description>&lt;p&gt;今年年初，Kenneth Reitz发布了Pipenv(https://www.kennethreitz.org/essays/announcing-pipenv), 目前已经是Python官方推荐的包管理工具(https://docs.pipenv.org/)。
个人之前一直都是用virtualenvwrapper(https://virtualenvwrapper.readthedocs.io/en/latest/),
virtualenvwrapper基本保持了大家之前对pip，virtualenv和requirements.txt的使用习惯，但是强大和方便了许多。如果要迁移到pipenv，需要对已有项目的包管理方式做较大的改变，因为pipenv
引入了新的机制。&lt;/p&gt;

&lt;h1 id=&quot;virtualenvwrapper&quot;&gt;virtualenvwrapper&lt;/h1&gt;

&lt;p&gt;virtualenvwrapper的方便之处在于不同项目的切换，以及同一项目不同虚拟环境之间的快速切换。&lt;/p&gt;

&lt;h2 id=&quot;install&quot;&gt;install&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip install virtualenvwrapper
...
$ export WORKON_HOME=~/Envs
$ mkdir -p $WORKON_HOME
$ source /usr/local/bin/virtualenvwrapper.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完以后，两个常用的命令一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;mkvirtualenv&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;rmvirtualenv&lt;/code&gt;. 所create的虚拟环境都会放到&lt;code class=&quot;highlighter-rouge&quot;&gt;WORKON_HOME&lt;/code&gt;里。&lt;/p&gt;

&lt;h2 id=&quot;create-a-project&quot;&gt;create a project&lt;/h2&gt;

&lt;p&gt;可以创建一个python3的虚拟环境。创建的同时，安装requirements.txt的依赖到虚拟环境里，并且进入到虚拟环境。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  tmp mkdir demo
➜  tmp cd demo
➜  demo touch requirements.txt
➜  demo echo &quot;flask&quot; &amp;gt;&amp;gt; requirements.txt
➜  demo mkvirtualenv --python=/usr/local/bin/python3.5 demo3 -a . -r requirements.txt
Running virtualenv with interpreter /usr/local/bin/python3.5
Using base prefix '/Library/Frameworks/Python.framework/Versions/3.5'
New python executable in demo3/bin/python3.5
Also creating executable in demo3/bin/python
Installing setuptools, pip, wheel...done.
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo3/bin/predeactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo3/bin/postdeactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo3/bin/preactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo3/bin/postactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo3/bin/get_env_details
Setting project for demo3 to /Users/penxiao/tmp/demo
You are using pip version 7.1.0, however version 9.0.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
Collecting flask (from -r requirements.txt (line 1))
  Using cached Flask-0.12.2-py2.py3-none-any.whl
....
....
Successfully installed Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.13 click-6.7 flask-0.12.2 itsdangerous-0.24
(demo3)➜  demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以再创建一个Python2的虚拟环境。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(demo3)➜  demo mkvirtualenv demo2 -a . -r requirements.txt
New python executable in demo2/bin/python
Installing setuptools, pip, wheel...done.
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo2/bin/predeactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo2/bin/postdeactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo2/bin/preactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo2/bin/postactivate
virtualenvwrapper.user_scripts creating /Users/penxiao/PycharmProjects/virtualenv/demo2/bin/get_env_details
Setting project for demo2 to /Users/penxiao/tmp/demo
You are using pip version 7.1.0, however version 9.0.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
Collecting flask (from -r requirements.txt (line 1))
  Using cached Flask-0.12.2-py2.py3-none-any.whl
....
(demo2)➜  demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过workon命令可以在不同的project和虚拟环境里切换。并且可以自动cd到项目目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(demo2)➜  demo workon demo3
(demo3)➜  demo deactivate
cd%                                                                                                                                                                         ➜  demo cd
➜  ~ workon demo2
(demo2)➜  demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;pipenv&quot;&gt;Pipenv&lt;/h1&gt;

&lt;p&gt;pipenv基本抛弃了requirements.txt这一套东西，引入了&lt;code class=&quot;highlighter-rouge&quot;&gt;Pipfile&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Pipfile.lock&lt;/code&gt;两个文件对虚拟环境进行管理。&lt;/p&gt;

&lt;h2 id=&quot;install-1&quot;&gt;install&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pip install pipenv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;create-a-project-1&quot;&gt;create a project&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  tmp cd demo
➜  demo pipenv --python 2.7
Creating a virtualenv for this project…
Using /usr/bin/python2.7 to create virtualenv…
⠋Running virtualenv with interpreter /usr/bin/python2.7
New python executable in /Users/penxiao/PycharmProjects/virtualenv/demo-hgu7fb10/bin/python
Installing setuptools, pip, wheel...done.

Virtualenv location: /Users/penxiao/PycharmProjects/virtualenv/demo-hgu7fb10
Creating a Pipfile for this project…
➜  demo ls
Pipfile
➜  demo pipenv install flask
Installing flask…
Collecting flask
  Using cached Flask-0.12.2-py2.py3-none-any.whl
Collecting click&amp;gt;=2.0 (from flask)
  Using cached click-6.7-py2.py3-none-any.whl
Collecting itsdangerous&amp;gt;=0.21 (from flask)
Collecting Werkzeug&amp;gt;=0.7 (from flask)
  Using cached Werkzeug-0.13-py2.py3-none-any.whl
Collecting Jinja2&amp;gt;=2.4 (from flask)
  Using cached Jinja2-2.10-py2.py3-none-any.whl
Collecting MarkupSafe&amp;gt;=0.23 (from Jinja2&amp;gt;=2.4-&amp;gt;flask)
Installing collected packages: click, itsdangerous, Werkzeug, MarkupSafe, Jinja2, flask
Successfully installed Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.13 click-6.7 flask-0.12.2 itsdangerous-0.24

Adding flask to Pipfile's [packages]…
Locking [dev-packages] dependencies…
Locking [packages] dependencies…
Updated Pipfile.lock (36eec0)!
➜  demo ls
Pipfile      Pipfile.lock
➜  demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pipfile&lt;/code&gt;里存储了project demo的依赖，比如当前是在Python2.7环境下依赖flask。 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Pipfile.lock&lt;/code&gt;文件里则详细记录了深层次的依赖关系，包括flask的当前版本，哈希，已经flask
所依赖的所有package的版本号和哈希值。&lt;/p&gt;

&lt;h2 id=&quot;run&quot;&gt;run&lt;/h2&gt;

&lt;p&gt;如果想在虚拟环境里运行代码，可以&lt;code class=&quot;highlighter-rouge&quot;&gt;pipenv shell&lt;/code&gt;进入虚拟环境，然后可以run代码，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;退出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  demo pipenv shell
Spawning environment shell (/bin/zsh). Use 'exit' to leave.
source /Users/penxiao/PycharmProjects/virtualenv/demo-hgu7fb10/bin/activate
➜  demo source /Users/penxiao/PycharmProjects/virtualenv/demo-hgu7fb10/bin/activate
(demo-hgu7fb10)➜  demo
(demo-hgu7fb10)➜  demo exit
➜  demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pipenv目前有一个feature没有实现，就是如何一个项目里并行多个虚拟环境，就像之前virtualenvwrapper一个project，Python2和Python3自由切换（https://github.com/pypa/pipenv/issues/1071，
但是官方貌似不打算实现这个。&lt;/p&gt;

&lt;p&gt;更多的详细内容可以阅读pipenv的文档或者github repo&lt;/p&gt;

&lt;p&gt;https://github.com/pypa/pipenv&lt;/p&gt;

&lt;p&gt;https://docs.pipenv.org/&lt;/p&gt;

&lt;h1 id=&quot;summary&quot;&gt;summary&lt;/h1&gt;

&lt;p&gt;总体来说，pipenv在严谨性和安全性上完全胜出，在易用性上也ok。但是在多个环境和项目管理上有所欠缺。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Dec 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/python/2017/12/10/pipenv.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/python/2017/12/10/pipenv.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Sharing of Selenium Testing Framework</title>
        <description>&lt;h1 id=&quot;what-is-selenium&quot;&gt;What is Selenium?&lt;/h1&gt;

&lt;p&gt;From the http://www.seleniumhq.org/, it gives a clear definition: Selenium automates browsers. That’s it!&lt;/p&gt;

&lt;p&gt;Please check out below links if you are interest:&lt;/p&gt;

&lt;h3 id=&quot;getting-started&quot;&gt;Getting started&lt;/h3&gt;

&lt;p&gt;http://selenium-python.readthedocs.io/getting-started.html (For Python)&lt;/p&gt;

&lt;h3 id=&quot;source-code&quot;&gt;Source Code&lt;/h3&gt;

&lt;p&gt;https://github.com/SeleniumHQ/selenium&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In generally, if your application is web-oriented and with using the Selenium for functional testing and unit test for data/backend logical testing,
You would get an complete web application testing solution.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;also-want-to-share-some-python-coding-tips-that-i-got-during-the-refactor-of-vots-project&quot;&gt;Also want to share some python coding tips that I got during the refactor of vots project&lt;/h4&gt;

&lt;h5 id=&quot;section&quot;&gt;1.&lt;/h5&gt;

&lt;p&gt;We know that everything is an object in python, so it makes easy for us to write ‘table-driven’ methods in python.
For example, we get many ‘if-else’ and complex logic in each ‘if’, then we can use table-driven, extract the ‘if’ condition into ‘key’, and the ‘logic into ‘value’ of a map.
Likes below :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def do_print(in_str: str):
    print(in_str)
                
def do_print_with_pre(in_str: str):
    print('pre - ' + in_str)


def do_print_with_end(in_str: str):
    print(in_str + ' - end')


operations = {'1': do_print, '2': do_print_with_pre, '3': do_print_with_end}

operations['1']('CISCO')
operations['2']('CISCO')
operations['3']('CISCO')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-1&quot;&gt;2.&lt;/h5&gt;

&lt;p&gt;From above screenshot we can see python support for type hints already. This is new in version 3.5 and I think is very helpful especially when the input parameter is an complex object .
The function below takes and returns a string and is annotated as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def greeting(name: str) -&amp;gt; str:
    return 'Hello ' + name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3.&lt;/h4&gt;

&lt;p&gt;Write unit test for your code.
For example, Vots project has two threads with loop and this makes it hard to debug when we get a bug.
Unit test and ‘mock’ can solve this issue.
First we reproduce bug and record real response into a txt file.
Second we write unit test for our code, and mock the return value of the related methods with the real response in the txt file.
Then we can begin debug from the unit test.
Except this, unit test can improve the quality of your code and make it easy to maintenance your code for continue delivery.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Aug 2017 04:35:33 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/python/2017/08/27/selenium-testing-framework.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/python/2017/08/27/selenium-testing-framework.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>网络学习和CCIE认证</title>
        <description>&lt;p&gt;本文假设你没有任何网络基础，从头开始，打算在2-3年内达到某一个方向CCIE的水准（不是paper IE）, 以我个人的经历梳理的一个计划。对于每一个部分需要花的时间，不同的人会有不同的情况，要依情况而定。但是总体来讲，在不影响工作的前提下，稳步提升，2-3年是一个比较合理的时间。&lt;/p&gt;

&lt;p&gt;我是2010年7月11号开始在思科实习，为期一年，2011年初考了CCNA，然后开始学习CCNP，但是并没有考CCNP的认证，主要时间用来学习OSPF和BGP。从2012年开始准备CCIE，2013年5月获取了CCIE SP的认证。&lt;/p&gt;

&lt;p&gt;学习过程中一定要理论+实践，实践要占高的比重，另外如果能做一些笔记记录就更好了。我在那三年时间，大概写了70篇相关技术博客。下面我就按照从基础——&amp;gt;CCNA——&amp;gt;CCNP——&amp;gt;CCIE的顺序，总结一下大概的学习流程。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;1. 基础篇&lt;/h1&gt;

&lt;p&gt;在基础篇里，基本不会涉及和接触到具体网络设备，而偏重于理论和概念，但是非常重要，这是学习后面所有知识的基础。&lt;/p&gt;

&lt;p&gt;如果大学或者研究生课程学过类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;通信网基本概念与主体结构&lt;/code&gt;[&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;] 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;计算机网络&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;通信网基础&lt;/code&gt;等课程，那么基础篇可以略过了，因为你已经掌握了&lt;strong&gt;网络分层&lt;/strong&gt;，&lt;strong&gt;TCP/IP协议&lt;/strong&gt;，&lt;strong&gt;路由算法&lt;/strong&gt;的基本概念。（不太自信的话，也可以复习一遍）&lt;/p&gt;

&lt;h3 id=&quot;tcpip&quot;&gt;1.1 TCP/IP基础&lt;/h3&gt;

&lt;p&gt;如何学习TCP/IP协议，可以参考知乎的一篇问答“如何学习tcp ip协议”[&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;]. 总结一下基本有这么两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;理论：TCP,UDP,IP,ARP,ICMP,DHCP,DNS等.&lt;/li&gt;
  &lt;li&gt;实践: 理论是枯燥的，实践是有趣的
    &lt;ul&gt;
      &lt;li&gt;基础实践：使用wireshark抓包分析网页打开的过程，HTTP, TCP三次握手&lt;a href=&quot;&quot;&gt;http://web.engr.oregonstate.edu/~qassimy/index_files/WiresharkLab-HTTP-Ch2-Sol.pdf&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;基础实践：使用熟悉的编程语言写socket小程序，并抓包分析. 例如：&lt;a href=&quot;&quot;&gt;http://www.binarytides.com/python-socket-programming-tutorial/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;进阶实践：使用scapy做各种发包实验 &lt;a href=&quot;&quot;&gt;https://github.com/secdev/scapy&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-1&quot;&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;《计算机网络》[&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;]&lt;/li&gt;
  &lt;li&gt;《TCP/IP详解卷一：协议》[&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;]&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;工具&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;wireshark&lt;/code&gt;[&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;]&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 路由协议基础&lt;/h3&gt;

&lt;p&gt;主要还是概念性的东西。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;路由器的基本概念&lt;/li&gt;
  &lt;li&gt;静态路由和动态路由的概念（距离矢量算法和链路状态算法）。&lt;/li&gt;
  &lt;li&gt;RIP/OSPF/BGP基本概念&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;ccna&quot;&gt;2. CCNA篇&lt;/h1&gt;

&lt;p&gt;在基础篇的基础下，增加对路由器交换机设备的接触，可以以CCNA学习指南[&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;]为参考资料，以Cisco Packet tracer[&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;]为模拟器进行试验操作。
在操作上，基本上要达到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;交换机路由器telnet的配置&lt;/li&gt;
  &lt;li&gt;对于交换机路由器的接口IP配置&lt;/li&gt;
  &lt;li&gt;VLAN的基本配置&lt;/li&gt;
  &lt;li&gt;路由协议RIP/EIGRP/OSPF的简单配置&lt;/li&gt;
  &lt;li&gt;基本的show命令&lt;/li&gt;
  &lt;li&gt;基本的网络排错能力（ping，traceroute，telnet，arp）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果能在不背诵题库，全部理解的前提下通过CCNA的考试。（我个人大概花了小半年的时间在CCNA上，2010年低-2011年初，记录了一些博客&lt;a href=&quot;&quot;&gt;http://blog.sina.com.cn/s/articlelist_1263548705_10_1.html&lt;/a&gt;）&lt;/p&gt;

&lt;h1 id=&quot;ccnp&quot;&gt;3. CCNP篇&lt;/h1&gt;

&lt;p&gt;我个人没有考过CCNP，个人感觉如果不考试，NP阶段的学习重点是各种路由协议，这个学习不是简单会配置（在入门篇已达到这个水平），而是要深入学习。
基本方式就是GNS3[&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;]（或者IOL）加wireshark抓包分析，配置手册和相关的RFC也需要看看。此时的实验拓扑一般比较小，不太会出现IE那种复杂拓扑。&lt;/p&gt;

&lt;p&gt;我下面以OSPF和BGP为例，其它协议RIPv2，EIGRP，ISIS类似。&lt;/p&gt;

&lt;h2 id=&quot;ospf&quot;&gt;3.1 OSPF&lt;/h2&gt;

&lt;p&gt;主要就是做实验做实验！可以参考OSPF命令行配置手册。
《Cisco OSPF Command and Configuration Handbook》[&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OSPF的邻接怎么建立起来（抓包分析）&lt;/li&gt;
  &lt;li&gt;OSPF的五种数据包类型，以及在建立邻接关系过程中各起到什么作用？&lt;/li&gt;
  &lt;li&gt;OSPF的特殊区域类型&lt;/li&gt;
  &lt;li&gt;OSPF的LA类型（抓包）&lt;/li&gt;
  &lt;li&gt;OSPF Area&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bgp&quot;&gt;3.2 BGP&lt;/h2&gt;

&lt;p&gt;《Cisco BGP-4 Command and Configuration Handbook》[&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;] ，RFC 4271[&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BGP邻居建立过程（抓包分析）&lt;/li&gt;
  &lt;li&gt;BGP Message类型（Open，Update，Keepalive，Notification）&lt;/li&gt;
  &lt;li&gt;IBGP，RR，RR Client，EBGP的概念和配置&lt;/li&gt;
  &lt;li&gt;基本的BGP Route Policy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果打算考CCNP，建议再看看题库，考试大纲，指南。个人不太建议CCNP，其实直接选一个方向深入进去，准备CCIE就可以的。&lt;/p&gt;

&lt;h1 id=&quot;cciesp&quot;&gt;4. CCIE篇（SP方向）&lt;/h1&gt;

&lt;p&gt;CCIE的方向有很多，比较大众的Routing Switch方向和Service Provider方向，因为项目需要，我需要专攻BGP，所以CCIE选择了SP方向，&lt;/p&gt;

&lt;p&gt;SP方向的重中之重是MPLS VPN。必看书籍为《MPLS和VPN体系结构》[&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;]，以卷1为主，卷2为辅。另外还有一些组播和l2vpn的内容，建议不要一上来就做CCIE的lab题库，要先过知识点，每一个知识点都要动手做实验。CCIE我大概写了28篇相应的博客&lt;a href=&quot;&quot;&gt;http://blog.sina.com.cn/s/articlelist_1263548705_15_1.html&lt;/a&gt;，另外网络上资源也非常多，各种博客，视频也是学习的好工具。&lt;/p&gt;

&lt;p&gt;这样到最后，再去做lab题库，会非常顺手，然后考前准备就是一个敲命令行的熟练度问题了.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;4.1 试验环境的搭建&lt;/h2&gt;

&lt;p&gt;CCIE SP方向的考试，实验拓扑的设备基本都是IOS-XR, 很多配置和IOS语法略有不同。真正准备考试的拓扑可以使用XRv[&lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;]去搭建。XRv比较消耗系统资源，所以在平时知识点学习的时候，个人还是建议使用GNS3.
因为机制是一样的，只不过配置语法不同，关键是GNS3“即插即用”，搭建拓扑拖拖拽拽非常简单，更重要的是，通过wireshark抓包非常方便，这点非常重要。对于IOS-XR配置的训练可以从后期准备实验真题练习开始。&lt;/p&gt;

&lt;h2 id=&quot;igp&quot;&gt;4.2 IGP&lt;/h2&gt;

&lt;p&gt;CCIE SP方向考试，IGP比较简单，基本就是IPv4+IPv6单区域的OSPF或者ISIS。在考试中，IGP是后面所有的配置的基础，特别是BGP。因为IBGP neighbor都是以Loopback0作为update-source，所以要保证一个BGP AS里所有的loopback0接口都能相互ping通（IPv4+IPv6）。要熟悉ping，扩展ping，traceroute等trouble shooting工具，因为错误在所难免，少配置一行，多一行很常见，所以要有基本的trouble shooting能力。&lt;/p&gt;

&lt;h2 id=&quot;bgp-1&quot;&gt;4.3 BGP&lt;/h2&gt;

&lt;p&gt;对于IBGP，EBGP，RR-client配置要非常熟悉。然后就是MPLS VPN的基本配置，PE，CE。最后是Inter-AS VPN那几种option，以及CSC。&lt;/p&gt;

&lt;p&gt;trouble shooting还是一样的，各种ping，show命令一跳跳查找故障点。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;4.4 组播&lt;/h2&gt;

&lt;p&gt;组播刚看概念会比较抽象一些，所以我做了很多实验，包括使用Python和一些软件自己建立组播源。大家可以参考&lt;a href=&quot;&quot;&gt;http://blog.sina.com.cn/s/articlelist_1263548705_15_1.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;4.5 其它&lt;/h2&gt;

&lt;p&gt;参考考试大纲[&lt;sup id=&quot;fnref:14&quot;&gt;&lt;a href=&quot;#fn:14&quot; class=&quot;footnote&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;]。&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;5. 后续&lt;/h1&gt;

&lt;p&gt;学习网络知识并不是为了考一个CCIE认证，当拿到一个认证以后，后期还是要继续学习的，一是知识会遗忘，二是新技术层出不穷，要多多去接触，比如SDN，container等等。&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;通信网基本概念与主体结构 &lt;a href=&quot;&quot;&gt;https://item.jd.com/10078500.html&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;如何学习TCP/IP协议？&lt;a href=&quot;&quot;&gt;https://www.zhihu.com/question/28943943&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;计算机网络 &lt;a href=&quot;&quot;&gt;https://book.douban.com/subject/2970300/&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;《TCP/IP详解卷一：协议》&lt;a href=&quot;&quot;&gt;https://book.douban.com/subject/1088054/&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;WireShark &lt;a href=&quot;&quot;&gt;https://www.wireshark.org/&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;CCNA学习指南 &lt;a href=&quot;&quot;&gt;https://book.douban.com/subject/2968802/&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot;&gt;
      &lt;p&gt;Cisco Packet tracer &lt;a href=&quot;&quot;&gt;https://www.netacad.com/about-networking-academy/packet-tracer/&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:8&quot;&gt;
      &lt;p&gt;GNS3 &lt;a href=&quot;&quot;&gt;https://www.gns3.com/&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:9&quot;&gt;
      &lt;p&gt;Cisco OSPF Command and Configuration Handbook &lt;a href=&quot;&quot;&gt;http://www.ciscopress.com/store/cisco-ospf-command-and-configuration-handbook-9781587050718&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:10&quot;&gt;
      &lt;p&gt;Cisco BGP-4 Command and Configuration Handbook &lt;a href=&quot;&quot;&gt;http://www.ciscopress.com/store/cisco-bgp-4-command-and-configuration-handbook-9781587050176&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:11&quot;&gt;
      &lt;p&gt;RFC 4271 &lt;a href=&quot;&quot;&gt;https://tools.ietf.org/html/rfc4271&lt;/a&gt; &lt;a href=&quot;#fnref:11&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:12&quot;&gt;
      &lt;p&gt;MPLS和VPN体系结构 &lt;a href=&quot;&quot;&gt;https://book.douban.com/subject/4896791/&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:13&quot;&gt;
      &lt;p&gt;Cisco XRv &lt;a href=&quot;&quot;&gt;https://docs.gns3.com/appliances/cisco-iosxrv.html&lt;/a&gt; &lt;a href=&quot;#fnref:13&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:14&quot;&gt;
      &lt;p&gt;CCIE Service Provider &lt;a href=&quot;&quot;&gt;http://www.cisco.com/c/en/us/training-events/training-certifications/certifications/expert/ccie-service-provider.html&lt;/a&gt; &lt;a href=&quot;#fnref:14&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 18 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/network/2017/07/18/network-path.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/network/2017/07/18/network-path.html</guid>
        
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 1 - wsgi</title>
        <description>&lt;p&gt;要读懂本篇，你至少得写过一个python的web程序，并且把它部署到web服务器上过。&lt;/p&gt;

&lt;h2 id=&quot;wsgi&quot;&gt;什么是wsgi&lt;/h2&gt;

&lt;p&gt;假设你写了一个python的web程序，并部署到了nginx上，那么你应该知道一个http request的处理流程一般是下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;client/浏览器（发送请求）  - - - - &amp;gt; web服务器(转发该请求) - - - - &amp;gt; 你的程序（1. 处理请求。2.生成结果。3.返回结果）
                                                                                                      |
                                                                                                      |
                                                                                                      V
                               client/浏览器（收到结果） &amp;lt;- - - -web服务器（接受你的程序返回的结果，并返回给浏览器）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;问题是，开发web程序的人和开发web服务器的人并没有沟通，为什么web application 能够部署在web 服务器上呢？ 这是因为他们都遵循了相同的规则 – WSGI。 WSGI 全名叫 web server gateway interface， 是python 中web程序和web服务器沟通的标准。 简单的说，只要你写的web application 遵守这个规则，另一个人开发的web 服务器也遵循这个规则，那么你写的程序就能运行在他开发的web服务器上。&lt;/p&gt;

&lt;h2 id=&quot;wsgi-application&quot;&gt;wsgi application&lt;/h2&gt;

&lt;p&gt;WSGI对application和server做出了不同的规定，大部分人不需要写server,因此我们只了解一下application的规定即可。首先看一个标准的WSGI application。该application的功能是，返回client所使用的http method(GET/POST等)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def application(env, callback):
	&quot;&quot;&quot;
	web server 实际上只做两件事
	1. 传递请求给application
	2. 接受application的返回
	env 就是server 给 application 传递请求的方式。 env是一个字典，除了客户端的请求信息，还包括很多其他的环境变量如http header等
	callback 是server 传递给application 的callback函数。 application 通过调用该函数，返回一些信息给server
	&quot;&quot;&quot;

	# EVN中包含了client 的各种环境变量，从中可以获取http method
	response_body = 'The request method was %s' % env['REQUEST_METHOD']

	# HTTP response的结果通常会有一个状态值和message。
	# 比如， 状态有500/404/403/200等， message 有OK/Not Found/Internal error/Forbidden 等。
	# 这里我们返回200 OK. 代表成功处理请求
	status = '200 OK'

	# HTTP response 的header 会包含一些必要的信息以便浏览器方便处理response。 这些必要的header信息需要按照以下格式放入list中
	response_headers = [('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body)))]

	# 利用callback 告诉server这次访问的状态信息以及 response header。
	callback(status, response_headers)

	# response 的body必须是一个iterable的对象。 我们这里把response body 放入一个list。（string虽然也是可迭代对象，但string的迭代次数显然远远大于这个list。会影响效率）
	return [response_body]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总结上面的代码，可知道WSGI 对application 只做了如下几点规定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. application 必须是可调用的object, 如函数,实现了__call__的对象

2. application 必须接收一个字典类型的参数用于保存环境变量，一个callback function

3. application 内要使用callback 返回 http status 和 response header

4. 返回值必须是iterable的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们用一个简单的wsgi server来调用一下上面的 application， 看一下效果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from wsgiref.simple_server import make_server
httpd = make_server('localhost', 8051, application)
httpd.serve_forever()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码启动了一个wsgi server监听在localhost:8051， 并且把我们的application 部署到了该server上。 我们访问localhost 8051,看一下效果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [root@netflow-AIO ~]# curl -i http://127.0.0.1:8051
    HTTP/1.0 200 OK
    Date: Sat, 26 Nov 2016 07:34:38 GMT
    Server: WSGIServer/0.1 Python/2.7.5
    Content-Type: text/plain
    Content-Length: 26

    The request method was GET
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到， application 成功返回了代码中指定的response message，并且http code / http msg / response header 也都和代码中指定的一样。&lt;/p&gt;

&lt;h2 id=&quot;wsgi-server&quot;&gt;wsgi server&lt;/h2&gt;

&lt;p&gt;大多数情况我们不需要编写server，因此不必了解太深。 但至少我们应该知道，在server中一定有这样的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;callable(env, callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里是server 调用application的地方。callable 是application对象的名字， env 是包含环境变量的字典，callback 是server传递给application的callback函数。想在applicaiton 被调用之前加一些逻辑，你可以在这行代码之前做改动。想修改application的返回结果，你可以在这行代码之后加逻辑&lt;/p&gt;

&lt;h2 id=&quot;wsgi-&quot;&gt;wsgi 中间件&lt;/h2&gt;

&lt;p&gt;WSGI 标准中除了application / server 还有一个很重要的概念–middleware。 其实 middleware 很好理解。 我们知道 server 会调用 application 处理请求， application 会把请求结果返回给server. Middleware，顾名思义就是在server 和 application 中间的一个对象。  对于server 来说 middleware 是一个application, 对于 application 来说， middleware 是一个server。也就是说,middleware同时实现了WSGI中对 application 和 server所做的规定。&lt;/p&gt;

&lt;p&gt;因为WSGI的这一特性，很多按照wsgi构建的系统都会有如下这样的结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app1 app2 app3 ... appN server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当一个http request发给server 时， 该请求会依次传递给 appN … app3 app2 app1, 然后response 又会从app1 开始往回传递直到 server 最后返回给客户端。也就是说，WSGI的系统是可以无限堆叠中间件的，你可以把自己的业务逻辑包装成一个个的中间件，需要的时候部署上去，不需要就拿下来。 openstack中所有的服务都是依照wsgi写的，因此也遵循这种结构。 比如neutron 服务的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;request_id catch_errors authtoken keystonecontext extensions neutronapiapp_v2_0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 catch_errors , authtoken, keystonecontext , extensions 都是WSGI的中间件。 了解了这些之后，我们可以做很多事情， 比如拿掉 authoken 和 keystonecontext, 这样调用neutron 的API就可以绕过权限校验了，因为这两个中间件是做权限校验用的。&lt;/p&gt;

&lt;h2 id=&quot;app--server&quot;&gt;App 中间件 server示例&lt;/h2&gt;

&lt;p&gt;接下来我们用一个例子展示一下 wsgi application middleware server 到底是什么样的。&lt;/p&gt;

&lt;p&gt;首先我们设计一个app，假设带着一个参数访问该app，它将告诉你该参数是奇数还是偶数。 api的url 假设是 check_number/&lt;number&gt;, 代码如下：&lt;/number&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def check_number(env, start_response):

    number = int(env.get('PATH_INFO').split('/')[-1])
    response_body = 'even' if number%2 == 0 else 'odd'

    status = '200 OK'
    response_headers = [('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body)))]
    start_response(status, response_headers)
    return [response_body]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码非常简单，因为我们假设url为check_number/&lt;nunber&gt;， 所以int(env.get('PATH_INFO').split('/')[-1])可以很轻松得到参数。这里我们不考虑异常。&lt;/nunber&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们设计一个middleware， 用于校验， 该middleware会检查http 访问的header， 如果带有特定的token，则认为是可信任用户，可以放行，继续访问check_number， 否则返回403 Forbidden。 代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class AuthToken(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, env, start_response):
        if env.get('HTTP_TOKEN') == '222':
            return self.app(env, start_response)
        else:
            response_body = 'Auth failed'
            status = '403 forbidden'
            response_headers = [('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body)))]
            start_response(status, response_headers)
            return [response_body]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里稍微解释一下。 所谓中间件，肯定要能被server 调用， 所以必须提供__call__(env, start_response)接口，并且返回可迭代的return 如[response_body]。 但同时它又需要调用别的app。
看我们AuthToken的代码，可以看到，它的逻辑就是，如果token合法（等于222） ，则继续调用application， 否则返回错误。&lt;/p&gt;

&lt;p&gt;有了验证中间件AuthToken, 有了业务逻辑check_number， 我们还可以再加一个中间件 CheckError。 该中间件捕捉所有的error / exception， 返回一个用户友好的消息，如 service maintain 等， 而不是直接把异常抛给用户。 代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CheckError(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, env, start_response):
        try:
            return self.app(env, start_response)
        except Exception as e:
            response_body = 'Server is maintaining '
            status = '503  service maintain'
            response_headers = [('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body)))]
            start_response(status, response_headers)
            return [response_body]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;逻辑很简单，如果有错误，则返回  service maintain， 否则返回正常的业务处理结果。&lt;/p&gt;

&lt;p&gt;接下来可以部署这些程序到服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from wsgiref.simple_server import make_server
httpd = make_server('10.79.99.86', 8051, CheckError(AuthToken(check_number)))
httpd.serve_forever()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;尝试访问：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@netflow-AIO bin]# curl http://10.79.99.86:8051/check_number/100 -H &quot;token:222&quot;
even

[root@netflow-AIO bin]# curl http://10.79.99.86:8051/check_number/100 -H &quot;token:wrong&quot;
Auth failed

[root@netflow-AIO bin]# curl http://10.79.99.86:8051/check_number/aaa -H &quot;token:222&quot;
Server is maintaining 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后面可以看到，网上对这种wsgi模块堆叠的部署方式叫pipeline。 但其实它和linux的pipeline不太一样， 其实是一种堆栈式的调用，调用流程图如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;request ----&amp;gt; server 生成 env 和 start_response
            ----&amp;gt; Check_Error.__call__
                ----&amp;gt;AuthToken.__call__
                    ----&amp;gt;Check_Number(env,start_response)
                    &amp;lt;----Check_Number 返回
                &amp;lt;----AuthToken 返回
            &amp;lt;----Check_Error 返回
response &amp;lt;----
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;wsgi-in-openstack&quot;&gt;WSGI in openstack&lt;/h2&gt;

&lt;p&gt;前面提到，写一个wsgi application 有若干规则要遵守，比如提供两个参数 env 和 callback ， 再比如return 一个可迭代对象。 这些规则其实跟业务逻辑无关。作为一个程序员，你可能更关心业务逻辑而不是wsgi的语法。你可能更希望写一个下面这样的程序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def application(req):
    # some logic
    return response
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;req 是客户的http 请求， response 是程序进行处理后的返回。这样对程序员来说就简单多了，只需要关心业务逻辑而不用关心wsgi稍显繁琐的语法。openstack中就实现了这样的简化，在openstack中，实现一个wsgi 程序可以这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import webob
import webob.dec
from webob.response import Response

@webob.dec.wsgify
def myapp(req):
    return Response(body=req.url)

from wsgiref.simple_server import make_server
httpd = make_server('localhost', 8051, myapp)
httpd.serve_forever()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;webob是用于web编程的一个model，通过它的wsgify这个装饰器，你可以很方便的把一个 接受 request 参数，返回response参数的函数转成wsgi application。现在你可以不必关心wsgi的细节，只要实现一个接受request 返回 response的函数就可以了。 默认情况下， req 是webob.request.Request类型的对象。&lt;/p&gt;

&lt;h2 id=&quot;sumary&quot;&gt;sumary&lt;/h2&gt;

&lt;p&gt;以上简单介绍了wsgi， 如果想对wsgi了解更多，可以参考pep3333&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-wsgi.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-wsgi.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 3 - stevedore</title>
        <description>&lt;p&gt;学习了WSGI/Paste deploy后，还需要对一些在openstack中一些package有一些了解，才能更好的理解openstack的代码&lt;/p&gt;

&lt;h1 id=&quot;what-is-stevedore&quot;&gt;What is stevedore&lt;/h1&gt;

&lt;p&gt;我们在写代码的时候通常把一个一个的功能块独立编写，甚至发布一定的规则和接口由第三方编写，然后在运行时根据实际情况来选择加载哪些功能模块。这样的好处是松耦合，灵活，而且便于协作。&lt;/p&gt;

&lt;p&gt;stevedore就是一个很好的帮助动态加载代码的工具，openstack中很多plugin就是通过stevedore加载的。&lt;/p&gt;

&lt;p&gt;下面通过一些应用场景看一下如何使用stevedore。&lt;/p&gt;

&lt;h1 id=&quot;driver-&quot;&gt;Driver 场景&lt;/h1&gt;

&lt;p&gt;假设我们有一个开源系统，我们不希望限定用户对数据库的选择。用户可以选择mysql/oracle/mongo等任意数据库。这就意味着我们需要对很多种数据库提供接口。这个工作量很大，并且要求开发人员对每一种数据库非常熟悉。最好的做法就是把数据库的接口设计成driver，并发布出该driver所需要实现的接口。这样任何第三方的组织或个人都可以参与开发。&lt;/p&gt;

&lt;p&gt;比如，我们定义下面的接口。任何开发者，只要编写一个实现了下列接口的class，就可以实现一个driver&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@six.add_metaclass(abc.ABCMeta)
class Base(object):
    &quot;&quot;&quot;
    The Base class for db driver
    &quot;&quot;&quot;

    @abc.abstractmethod
    def create_user(self, user_name):
        &quot;&quot;&quot;

        :param user_name:
            The name of user
        :return:
            A user object
        &quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基于上述接口，我们尝试开发一个mysql的driver如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mysql_driver.py
import base


class MysqlDriver(base.Base):
    def create_user(self, user_name):
        return &quot;create user %s in mysql&quot; % user_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该package的目录结构如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@controller POTUS]# tree MysqlDriver/
MysqlDriver/
├── mysql_driver
│   ├── __init__.py
│   └── mysql_driver.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要注意在mysql_driver/&lt;strong&gt;init&lt;/strong&gt;.py中要有 import mysql_driver这句话&lt;/p&gt;

&lt;p&gt;setup.py的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
    name='mysql_driver',
    version='1.0',

    packages=find_packages(),

    entry_points={
        'my_system.db_driver': [
            'mysql = mysql_driver.mysql_driver:MysqlDriver',
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行python setup.py install 后，会在系统目录中安装mysql_driver这个egg包，egg中有entry_point文件中记录了如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[my_system.db_driver]

mysql = mysql_driver.mysql_driver:MysqlDriver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;my_system.db_driver是操作系统全局唯一的namespace。mysql是entry point的名字。通过这两个组合，可以定位到需要加载的代码，也就是我们的driver。&lt;/p&gt;

&lt;p&gt;我们同样的再开发一个oracle_driver，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@controller POTUS]# tree OracleDriver/
OracleDriver/
├── oracle_driver
│   ├── __init__.py
│   └── oracle_driver.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;oracle_driver.py内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# mysql_driver.py
import base


class OracleDriver(base.Base):
    def create_user(self, user_name):
        return &quot;create user %s in oracle&quot; % user_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;setup.py内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
    name='oracle_driver',
    version='1.0',
    packages=find_packages(),
    entry_points={
        'my_system.db_driver': [
            'oracle = oracle_driver.oracle_driver:OracleDriver',
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不要忘了在__init__.py中加上 import oracle_driver。&lt;/p&gt;

&lt;p&gt;ok， 在python setup.py install 后，我们的系统中有了mysql_driver 和 oracle_driver 下面就是应用了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from stevedore import driver
&amp;gt;&amp;gt;&amp;gt; mgr = driver.DriverManager(namespace = &quot;my_system.db_driver&quot;, name = &quot;mysql&quot;, invoke_on_load = True, invoke_args = ())
&amp;gt;&amp;gt;&amp;gt; mgr.driver.create_user('Tom')
'create user Tom in mysql'
&amp;gt;&amp;gt;&amp;gt; mgr = driver.DriverManager(namespace = &quot;my_system.db_driver&quot;, name = &quot;oracle&quot;, invoke_on_load = True, invoke_args = ())
&amp;gt;&amp;gt;&amp;gt; mgr.driver.create_user('Tom')
'create user Tom in oracle'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，当name=mysql时，调用的是mysql_driver, 当name=oracle时，调用的是oracle_driver&lt;/p&gt;

&lt;p&gt;Driver的方式，让不同的driver开发过程相互独立，调用也更加灵活&lt;/p&gt;

&lt;h1 id=&quot;hook&quot;&gt;Hook场景&lt;/h1&gt;

&lt;p&gt;Hook 顾名思义，钩子。就像window开发中的hook一样，每一个hook都是一个功能组件，会被一定的事件驱动。一个事件可以驱动一个hook，也可以驱动多个hook。同一个hook可以被多个不同的事件驱动。&lt;/p&gt;

&lt;p&gt;假设我们开发了一个IDE工具，在鼠标点击关闭按钮的时候，会产生CLOSE_WINDOW EVENT， 这时候需要save_content组件保存内容。在鼠标点击commit按钮的时候，会产生COMMIT EVENT，这时候需要save_content发挥作用，也需要upload_content组件把内容上传到服务器。&lt;/p&gt;

&lt;p&gt;这种场景下，我们可以开发save_content, upload_content两个组件，并且把save_content注册在CLOSE_WINDOW 和 COMMIT 两个event下，把upload_content注册在COMMIT event下。开发过程如下：&lt;/p&gt;

&lt;p&gt;首先是save_content,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@controller POTUS]# tree IDE_HOOKA/
IDE_HOOKA/
├── save_content
│   ├── __init__.py
│   └── save_content.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;save_content 内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SaveContent(object):
    def __call__(self, *args, **kwargs):
        return &quot;content are saved&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;setup.py 内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
    name='save_content',
    version='1.0',

    packages=find_packages(),

    entry_points={
        'ide.hooks': [
            'CLOSE_WINDOW = save_content.save_content:SaveContent',
            'COMMIT = save_content.save_content:SaveContent'
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;.py中有import save_content这句不要落下。&lt;/p&gt;

&lt;p&gt;在python setup.py install 后，save_content.save_content:SaveContent 会被注册到CLOSE_WINDOW 和 COMMIT这两个event下。&lt;/p&gt;

&lt;p&gt;我们再开发一个upload_content 组件如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@controller POTUS]# tree IDE_HOOKB/
IDE_HOOKB/
├── setup.py
└── upload_content
	├── __init__.py
	└── upload_content.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;主要看一下setup.py 
    from setuptools import setup, find_packages&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setup(
    name='upload_content',
    version='1.0',

    packages=find_packages(),

    entry_points={
        'ide.hooks': [
            'COMMIT = upload_content.upload_content:UploadContent'
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次，我们只注册了upload_content到COMMIT下。&lt;/p&gt;

&lt;p&gt;在安装后，我们有了save_content 注册在CLOSE_WINDOW 和 COMMIT下， upload_content注册在COMMIT下。这样，当COMMIT事件发生，系统会保存内容并upload内容到服务器，当CLOSE_WINDOW事件发生，会保存内容。&lt;/p&gt;

&lt;p&gt;运行如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# import hookmanager
# 定义运行hook的函数
&amp;gt;&amp;gt;&amp;gt; from stevedore import HookManager
&amp;gt;&amp;gt;&amp;gt; def run(hook):
...     return (hook.name, hook.obj())
... 

# 根据Close Window调用hook
&amp;gt;&amp;gt;&amp;gt; mgr = HookManager(namespace = &quot;ide.hooks&quot;, name = &quot;CLOSE_WINDOW&quot;, invoke_on_load = True, invoke_args = ())
&amp;gt;&amp;gt;&amp;gt; mgr.map(run)
[('CLOSE_WINDOW', 'content are saved')]

# 根据commit调用hook 
&amp;gt;&amp;gt;&amp;gt; mgr = HookManager(namespace = &quot;ide.hooks&quot;, name = &quot;COMMIT&quot;, invoke_on_load = True, invoke_args = ())
&amp;gt;&amp;gt;&amp;gt; mgr.map(run)
[('COMMIT', 'content are saved'), ('COMMIT', 'content are uploaded')]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;extension-&quot;&gt;extension 场景&lt;/h1&gt;

&lt;p&gt;对比driver hook，他们都是通过setuptools的entry point来调用代码。driver是根据一个名字加载一个driver， hook是根据一个名字加载多个组件，而extension则是不根据名字，把namespace下所有的组件加载。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@controller POTUS]# tree EXT/
EXT/
├── ext
│   ├── ext1.py
│   ├── ext2.py
│   ├── ext3.py
│   └── __init__.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ext1的内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class EXT1(object):
    def __call__(self, *args, **kwargs):
        return &quot;ext1 is called&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;setup.py内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
    name='ext',
    version='1.0',

    packages=find_packages(),

    entry_points={
        'my_namespace': [
            'ext1 = ext.ext1:EXT1',
            'ext2 = ext.ext2:EXT2',
            'ext3 = ext.ext3:EXT3'
        ],
    },
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;按照完成后，ext1/ext2/ext3都被注册到my_namespace下。 调用方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from stevedore import ExtensionManager
&amp;gt;&amp;gt;&amp;gt; mgr=ExtensionManager(namespace='my_namespace', invoke_on_load=True, invoke_args=())
&amp;gt;&amp;gt;&amp;gt; def run(hook):
...     return (hook.name, hook.obj)
... 
&amp;gt;&amp;gt;&amp;gt; mgr.map(run)
[('ext3', &amp;lt;ext.ext3.EXT3 object at 0xd62a50&amp;gt;), ('ext2', &amp;lt;ext.ext2.EXT2 object at 0x102b6d0&amp;gt;), ('ext1', &amp;lt;ext.ext1.EXT1 object at 0x1034c10&amp;gt;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用方式可以看到，通过namespace可以把其下所有组件加载&lt;/p&gt;

&lt;p&gt;以上是stevedore的主要用法，下一篇讲展示routes的用法&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-stevedore.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-stevedore.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 7 - service plugin</title>
        <description>&lt;p&gt;We have learned core plugin, service plugin and extension in last post. Now let`s review:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Core Plugin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Core plugin manage core resources which are network, subnet, port and subnetpool.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Service Plugin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Service plugin manage higher services.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;extension&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Extensions are called API Extensions. There are three types of extension&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;resource extension which define new resources&lt;/li&gt;
    &lt;li&gt;action extension which define actions for resource&lt;/li&gt;
    &lt;li&gt;request extension which can add more parameter to request&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Normally a new feature will be implemented by extension first. When the feature is stable, the community will move it to official api and may implement it in plugin.&lt;/p&gt;

&lt;p&gt;We write our core plugin in the previous post now we are going to write our service plugin.&lt;/p&gt;

&lt;h1 id=&quot;what-is-the-difference-between-core-plugin-and-service-plugin&quot;&gt;What is the difference between core plugin and service plugin&lt;/h1&gt;

&lt;p&gt;Core plugin manage core resource in neutron. The code structure is different from service plugin. But the community are considering transfer core plugin into one kind of service plugin. You will see the trend in code&lt;/p&gt;

&lt;h1 id=&quot;design-our-service-plugin&quot;&gt;Design our service plugin&lt;/h1&gt;

&lt;p&gt;Our service plugin is called “ZOO”. This plugin will manage some resource like “tiger”. We are going to do API call like CREATE/UPDATE/DELETE/GET tiger with this service plugin.&lt;/p&gt;

&lt;h1 id=&quot;write-our-service-plugin&quot;&gt;Write our service plugin&lt;/h1&gt;

&lt;p&gt;Service plugin must be inherited from the class neutron.services.service_base.ServicePluginBase&lt;/p&gt;

&lt;p&gt;Below are my service plugin&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from neutron.services import service_base


class ZooPlugin(service_base.ServicePluginBase):
	supported_extension_aliases = [&quot;zoo&quot;]

	def __init__(self):
		super(ZooPlugin, self).__init__()

	def get_plugin_name(self):
		return &quot;ZOO&quot;

	def get_plugin_type(self):
		# should be under neutron/plugins/common/constants.py
		return &quot;ZOO&quot;

	def get_plugin_description(self):
		return (&quot;ZOO&quot;)

	def create_tiger(self, context, tiger):
		return &quot;tiger created&quot;

	def get_tigers(self, context, filters, fields):
		return {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;supported_extension_aliases is necessary since we need an extension to generate the resource.&lt;/p&gt;

&lt;p&gt;We only support get_tigers and create_tiger here for simplicity purpose.&lt;/p&gt;

&lt;p&gt;Because the plugin is third-party code, so we have to register it under certain entry point so neutron can load it. So our code structure will be like :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@liberty-controller01 tmp]# tree zooServicePlugin
zooServicePlugin/
├── setup.py
└── zoo
	├── __init__.py
	├── zoo_plugin.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The content of setup.py is like&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
	name='zoo',
	version='1.0',

	packages=find_packages(),

	entry_points={
		'neutron.service_plugins': [
			'zoo = zoo.zoo_plugin:ZooPlugin',
		],
	},
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The key point here is to register the plugin under neutron.service_plugins namespace.&lt;/p&gt;

&lt;h1 id=&quot;write-the-extension&quot;&gt;Write the extension&lt;/h1&gt;

&lt;p&gt;We have service plugin ready to manage the tiger resource. But we do not have the tiger resource yet. One option is to modify the neutron/api/v2/attribute.py which is not suggested. The recommended way is to generate the resource by extension like below&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from neutron.api import extensions
from neutron.api.v2 import base
from neutron import manager


EXT_PREFIX = '/zoo'
RESOURCE_NAME = 'tiger'
COLLECTION_NAME = '%ss' % RESOURCE_NAME
RESOURCE_ATTRIBUTE_MAP = {
    'tiger': {
        'id': {'allow_post': False, 'allow_put': False,
               'validate': {'type:uuid': None},
               'is_visible': True,
               'primary_key': True},
        'name': {'allow_post': True,
                 'allow_put': False,
                 'is_visible': True,
                 'default': ''},
        'tenant_id': {'allow_post': True, 'allow_put': False,
                      'required_by_policy': True,
                      'validate': {'type:string': None},
                      'is_visible': True}
    }
}


class Zoo(extensions.ExtensionDescriptor):
    @classmethod
    def get_name(cls):
        return &quot;zoo&quot;

    @classmethod
    def get_alias(cls):
        return 'zoo'

    @classmethod
    def get_description(cls):
        return &quot;zoo&quot;

    @classmethod
    def get_updated(cls):
        return &quot;2017-02-08T10:00:00-00:00&quot;

    @classmethod
    def get_resources(cls):
        # This method registers the URL and the dictionary  of
        # attributes on the neutron-server.
        exts = list()
        plugin = manager.NeutronManager.get_service_plugins()['ZOO']
        resource_name = RESOURCE_NAME
        collection_name = COLLECTION_NAME
        params = RESOURCE_ATTRIBUTE_MAP.get(resource_name)
        controller = base.create_resource(collection_name, resource_name,
                                          plugin, params, allow_bulk=False)
        ex = extensions.ResourceExtension(collection_name, controller, path_prefix=EXT_PREFIX)
        exts.append(ex)
        return exts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The RESOURCE_ATTRIBUTE_MAP is used for define resource tiger. The tenant_id attribute is necessary for auth.&lt;/p&gt;

&lt;p&gt;An extension must inherited from extensions.ExtensionDescriptor&lt;/p&gt;

&lt;p&gt;get_alias method is really important because plugin will use this value to find the extension. This value must be in the supported_extension_alias of plugin&lt;/p&gt;

&lt;p&gt;The get_resources method is necessary for an extension who define new resource. We will see the detail in later post.&lt;/p&gt;

&lt;h1 id=&quot;config&quot;&gt;Config&lt;/h1&gt;

&lt;p&gt;Now we have our service plugin and extension we need to install our service plugin by python setup.py install and put the extension under neutron/extensions&lt;/p&gt;

&lt;p&gt;Also config the /etc/neutron/neutron.conf&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service_plugins = ...,zoo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Restart your neutron server and run below API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -g -i  &quot;http://liberty-controller01:9696/v2.0/zoo/tigers&quot; -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token:$token&quot;
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Content-Length: 14
X-Openstack-Request-Id: req-82ed8ccc-da9d-46d9-8fd9-beb01a24385b
Date: Wed, 08 Feb 2017 11:09:13 GMT

{&quot;tigers&quot;: []}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It work&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-service-plugin.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-service-plugin.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 4 - route</title>
        <description>&lt;p&gt;When coding a web system, you have to think about an important problem, how to map urls to logic.&lt;/p&gt;

&lt;p&gt;Openstack use routes to solve this problem.&lt;/p&gt;

&lt;h1 id=&quot;what-is-routes&quot;&gt;What is routes&lt;/h1&gt;

&lt;p&gt;Routes is a python package used to map urls to program logic. Normally this is the web framework`s responsibility, so besides openstack, routes is also used in several other python web frameworks.&lt;/p&gt;

&lt;h1 id=&quot;quick-start&quot;&gt;Quick start&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map = Mapper()
&amp;gt;&amp;gt;&amp;gt; map.connect('route_name_update_net', '/nets/{net_id}', controller='nets_controller', conditions=dict(method=['PUT']), self_defined_key='self_defined_value')
    # Above code created a route named &quot;route_name_update_net&quot;
    # It match any two component urls started with /nets
    # Controller which will process the request is nets_controller
    # Conditions parameter restrict the route only accept PUT request

&amp;gt;&amp;gt;&amp;gt; map.match('/nets/123')
{'controller': u'nets_controller', 'net_id': u'123', &quot;self_defined_key&quot;:&quot;self_defined_value&quot;}
    # As you can see, the url which match the route will return a dict. The dict contains the controller information and necessary var
    # The self_defined_key and self_defined_value also included. 

&amp;gt;&amp;gt;&amp;gt; print map
Route name            Methods Path          
route_name_update_net PUT     /nets/{net_id}
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;basic-usage&quot;&gt;Basic usage&lt;/h1&gt;

&lt;h2 id=&quot;requirements&quot;&gt;Requirements&lt;/h2&gt;

&lt;p&gt;Some times you want to restrict the path var, you can use the requirements parameter in below ways&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map.connect(R&quot;/download/{platform:windows|mac}/{filename}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This line restrict the platform var could only be windows or mac. You can also write it in below way&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map.connect(&quot;/download/{platform}/{filename}&quot;, requirements={&quot;platform&quot;: R&quot;windows|mac&quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The R char here is very important. Without it you may need to double your slash in your url.&lt;/p&gt;

&lt;p&gt;Once you restrict your route, you can try it like below:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# The platform must be windows or mac so below url match
&amp;gt;&amp;gt;&amp;gt; map.match('/download/windows/myfile')
{'platform': u'windows', 'filename': u'myfile'}
# The linux is not valid here so does not match
&amp;gt;&amp;gt;&amp;gt; map.match('/download/linux/myfile')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;pathinfo&quot;&gt;PATH_INFO&lt;/h2&gt;

&lt;p&gt;In WSIG env, the url information is stored in the environ dict with key PATH_INFO. 
Routes treat the path_info specially. When the “path_info” variable is used at the end of the URL, Routes moves everything preceding it into the “SCRIPT_NAME” environment variable. This is useful when delegating to another WSGI application that does its own routing: the subapplication will route on the remainder of the URL rather than the entire URL&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.connect('/classes/{path_info:.*}')
&amp;gt;&amp;gt;&amp;gt; map.match('/classes/students/tom')
{'path_info': 'students/tom'}
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The subsequent system will see PATH_INFO: /students/tom and SCRIPT_NAME:classes. So the sub system can use its own route system.&lt;/p&gt;

&lt;h2 id=&quot;format-extensions&quot;&gt;Format extensions&lt;/h2&gt;

&lt;p&gt;Consider to design a url /neutron/networks/{network_id} which will used to access the network resource. The network can be returned in JSON format or XML format. So we can do it in routes like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; map.connect('/neutron/networks/{network_id}{.format:json|xml}')
&amp;gt;&amp;gt;&amp;gt; map.match('/neutron/networks/123.json')
{'network_id': u'123', 'format': u'json'}
&amp;gt;&amp;gt;&amp;gt; map.match('/neutron/networks/123.xml')
{'network_id': u'123', 'format': u'xml'}
&amp;gt;&amp;gt;&amp;gt; map.match('/neutron/networks/123.html')
{'network_id': u'123.html', 'format': None}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Use the format parameter to specify the resource format&lt;/p&gt;

&lt;h1 id=&quot;restful&quot;&gt;RESTful&lt;/h1&gt;

&lt;p&gt;Use routes can generate restful routes very conveniently&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource('net','nets')
&amp;gt;&amp;gt;&amp;gt; print map
Route name         Methods Path                      
				   POST    /nets.:(format)           
				   POST    /nets                     
formatted_nets     GET     /nets.:(format)           
nets               GET     /nets                     
formatted_new_net  GET     /nets/new.:(format)       
new_net            GET     /nets/new                 
				   PUT     /nets/:(id).:(format)     
				   PUT     /nets/:(id)               
				   DELETE  /nets/:(id).:(format)     
				   DELETE  /nets/:(id)               
formatted_edit_net GET     /nets/:(id)/edit.:(format)
edit_net           GET     /nets/:(id)/edit          
formatted_net      GET     /nets/:(id).:(format)     
net                GET     /nets/:(id)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first parameter is resource name also called member in RESTful 
The second is the plural of resource name which is also called collection in RESTful&lt;/p&gt;

&lt;p&gt;the resource function have several parameters and we will learn them one by one&lt;/p&gt;

&lt;h2 id=&quot;controller&quot;&gt;controller&lt;/h2&gt;

&lt;p&gt;This parameter specify the controller to handle the request. For example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource('net','nets', controller='net_controller')
&amp;gt;&amp;gt;&amp;gt; map.match('/nets/123')
{'action': u'update', 'controller': u'net_controller', 'id': u'123'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;collection&quot;&gt;collection&lt;/h2&gt;

&lt;p&gt;This parameter add more additional urls for the collection operations. For example:&lt;/p&gt;

&lt;p&gt;Before use the parameter the map is like below&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource('net','nets', controller='net_controller')
&amp;gt;&amp;gt;&amp;gt; print map
Route name         Methods Path                      
				   POST    /nets.:(format)           
				   POST    /nets                     
formatted_nets     GET     /nets.:(format)           
nets               GET     /nets                     
formatted_new_net  GET     /nets/new.:(format)       
new_net            GET     /nets/new                 
				   PUT     /nets/:(id).:(format)     
				   PUT     /nets/:(id)               
				   DELETE  /nets/:(id).:(format)     
				   DELETE  /nets/:(id)               
formatted_edit_net GET     /nets/:(id)/edit.:(format)
edit_net           GET     /nets/:(id)/edit          
formatted_net      GET     /nets/:(id).:(format)     
net                GET     /nets/:(id)               
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After we add the collection parameter&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map.resource('net','nets', controller='net_controller', collection={'subnets':'POST'})
&amp;gt;&amp;gt;&amp;gt; print map
Route name             Methods Path                      
formatted_subnets_nets POST    /nets/subnets.:(format)   
subnets_nets           POST    /nets/subnets             
					   POST    /nets.:(format)           
					   POST    /nets                     
formatted_nets         GET     /nets.:(format)           
nets                   GET     /nets                     
formatted_new_net      GET     /nets/new.:(format)       
new_net                GET     /nets/new                 
					   PUT     /nets/:(id).:(format)     
					   PUT     /nets/:(id)               
					   DELETE  /nets/:(id).:(format)     
					   DELETE  /nets/:(id)               
formatted_edit_net     GET     /nets/:(id)/edit.:(format)
edit_net               GET     /nets/:(id)/edit          
formatted_net          GET     /nets/:(id).:(format)     
net                    GET     /nets/:(id)            
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The collection operation can mathc /nets/subnets on POST method.&lt;/p&gt;

&lt;h2 id=&quot;member&quot;&gt;member&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource('net','nets', controller='net_controller', member={'subnets':'POST'})
&amp;gt;&amp;gt;&amp;gt; print map
Route name            Methods Path                         
					  POST    /nets.:(format)              
					  POST    /nets                        
formatted_nets        GET     /nets.:(format)              
nets                  GET     /nets                        
formatted_new_net     GET     /nets/new.:(format)          
new_net               GET     /nets/new                    
					  PUT     /nets/:(id).:(format)        
					  PUT     /nets/:(id)                  
formatted_subnets_net POST    /nets/:(id)/subnets.:(format)
subnets_net           POST    /nets/:(id)/subnets          
					  DELETE  /nets/:(id).:(format)        
					  DELETE  /nets/:(id)                  
formatted_edit_net    GET     /nets/:(id)/edit.:(format)   
edit_net              GET     /nets/:(id)/edit             
formatted_net         GET     /nets/:(id).:(format)        
net                   GET     /nets/:(id)                  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After use member parameter, the member operation can match /nets/{id}/subnets&lt;/p&gt;

&lt;h2 id=&quot;pathprefix-and-nameprefix&quot;&gt;path_prefix and name_prefix&lt;/h2&gt;

&lt;p&gt;This two parameter are used together. For example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource(&quot;message&quot;, &quot;messages&quot;, controller=&quot;categories&quot;, path_prefix=&quot;/category/{category_id}&quot;, name_prefix=&quot;category_&quot;)
&amp;gt;&amp;gt;&amp;gt; print map
Route name                      Methods Path                                                 
								POST    /category/{category_id}/messages.:(format)           
								POST    /category/{category_id}/messages                     
formatted_category_messages     GET     /category/{category_id}/messages.:(format)           
category_messages               GET     /category/{category_id}/messages                     
formatted_category_new_message  GET     /category/{category_id}/messages/new.:(format)       
category_new_message            GET     /category/{category_id}/messages/new                 
								PUT     /category/{category_id}/messages/:(id).:(format)     
								PUT     /category/{category_id}/messages/:(id)               
								DELETE  /category/{category_id}/messages/:(id).:(format)     
								DELETE  /category/{category_id}/messages/:(id)               
formatted_category_edit_message GET     /category/{category_id}/messages/:(id)/edit.:(format)
category_edit_message           GET     /category/{category_id}/messages/:(id)/edit          
formatted_category_message      GET     /category/{category_id}/messages/:(id).:(format)     
category_message                GET     /category/{category_id}/messages/:(id)           
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The path_prefix add a url prefix to the urls that can be matched. The name_prefix is the prefix of route name.&lt;/p&gt;

&lt;p&gt;They actually are parent resource of message.&lt;/p&gt;

&lt;h2 id=&quot;parent-resource&quot;&gt;Parent resource&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map=Mapper()
&amp;gt;&amp;gt;&amp;gt; map.resource('location', 'locations', parent_resource=dict(member_name='region', collection_name='regions'))
&amp;gt;&amp;gt;&amp;gt; print map
Route name                     Methods Path                                              
							   POST    /regions/:region_id/locations.:(format)           
							   POST    /regions/:region_id/locations                     
formatted_region_locations     GET     /regions/:region_id/locations.:(format)           
region_locations               GET     /regions/:region_id/locations                     
formatted_region_new_location  GET     /regions/:region_id/locations/new.:(format)       
region_new_location            GET     /regions/:region_id/locations/new                 
							   PUT     /regions/:region_id/locations/:(id).:(format)     
							   PUT     /regions/:region_id/locations/:(id)               
							   DELETE  /regions/:region_id/locations/:(id).:(format)     
							   DELETE  /regions/:region_id/locations/:(id)               
formatted_region_edit_location GET     /regions/:region_id/locations/:(id)/edit.:(format)
region_edit_location           GET     /regions/:region_id/locations/:(id)/edit          
formatted_region_location      GET     /regions/:region_id/locations/:(id).:(format)     
region_location                GET     /regions/:region_id/locations/:(id)               
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is the same as path_prefix and name_prefix. The path_prefix here is /regions/{region_id} and name_prefix is region_&lt;/p&gt;

&lt;p&gt;openstack use routes to map url to controller, so it is necessary to know about routes. Routes are came from Ruby on rails. It is rewritten in python. So docs about routes are not very clear might because the author think we should learn Ruby on rails routes first.&lt;/p&gt;

&lt;h2 id=&quot;submapper&quot;&gt;Submapper&lt;/h2&gt;

&lt;p&gt;submapper is a lazy way to write code. See examples below:&lt;/p&gt;

&lt;p&gt;You want to generate a series route， they have common attributes like&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;controller: common_controller
action: index
path_prefix: api/v2
conditions: {'method':'GET'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can write the code in this way&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from routes import Mapper
&amp;gt;&amp;gt;&amp;gt; map = Mapper()
&amp;gt;&amp;gt;&amp;gt; with map.submapper(controller='common_controller', action='index', path_prefix='api/v2/', contidions={'method':'GET'}) as submapper:
...     submapper.connect('api/v2/'+'nets', 'nets')
...     submapper.connect('api/v2/'+'subnets', 'subnets')
... 
&amp;gt;&amp;gt;&amp;gt; print map
Route name     Methods Path          
api/v2/nets            api/v2/nets   
api/v2/subnets         api/v2/subnets
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In this way you can put the common attributes in submapper.&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-route.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-route.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 9 - request extension</title>
        <description>&lt;p&gt;We have learned resource extension and action extension. This post we will write a request extension&lt;/p&gt;

&lt;p&gt;First see two API call&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST http://liberty-controller01:9696/v2.0/networks.json -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token: $token&quot; -d '{&quot;network&quot;: {&quot;name&quot;: &quot;net3&quot;, &quot;admin_state_up&quot;: true}}'

{&quot;network&quot;: {&quot;status&quot;: &quot;ACTIVE&quot;, &quot;subnets&quot;: [], &quot;name&quot;: &quot;net3&quot;, &quot;provider:physical_network&quot;: &quot;physnet1&quot;, &quot;admin_state_up&quot;: true, &quot;tenant_id&quot;: &quot;8c5f13ee6a404759839e48537bdf69ac&quot;, &quot;mtu&quot;: 0, &quot;router:external&quot;: false, &quot;shared&quot;: false, &quot;port_security_enabled&quot;: true, &quot;provider:network_type&quot;: &quot;vlan&quot;, &quot;id&quot;: &quot;95c955ac-c963-4f53-ab4a-d721fa0cda51&quot;, &quot;provider:segmentation_id&quot;: 490}}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It run successful. Nothing to say. Then this one&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST http://liberty-controller01:9696/v2.0/networks.json -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token: $token&quot; -d '{&quot;network&quot;: {&quot;name&quot;: &quot;net3&quot;, &quot;admin_state_up&quot;: true, &quot;some_attr&quot;:&quot;some_value&quot;}}'

{&quot;NeutronError&quot;: {&quot;message&quot;: &quot;Unrecognized attribute(s) 'some_attr'&quot;, &quot;type&quot;: &quot;HTTPBadRequest&quot;, &quot;detail&quot;: &quot;&quot;}}[root@liberty-controller01 myPluginPKG]# 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This one is bad request. But the only difference is the POST body. Neutron think the some_attr is not a attribute of network and it is right. Because this is a core resource and the attribute map of this resource do not have some_attr&lt;/p&gt;

&lt;p&gt;To solve this we need an request extension which actually update the resource attribute map of network. Below are the code&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from neutron.api import extensions

EXTENDED_ATTRIBUTES_2_0 = {
    'networks': {
        'some_attr': {'allow_post': True,
                 'allow_put': False,
                 'is_visible': True,
                 'default': ''}
    }
}


class Myreq(extensions.ExtensionDescriptor):
    @classmethod
    def get_name(cls):
        return &quot;myreq&quot;

    @classmethod
    def get_alias(cls):
        return 'myreq'

    @classmethod
    def get_description(cls):
        return &quot;myreq&quot;

    @classmethod
    def get_updated(cls):
        return &quot;2017-02-08T10:00:00-00:00&quot;

    def get_extended_resources(self, *args, **kwargs):
        return EXTENDED_ATTRIBUTES_2_0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can see we defined a dict in the extension and return it with method get_extended_resources.&lt;/p&gt;

&lt;p&gt;So to implement an request extension is very easy. Define a method called get_extended_resources and return some attributes that you want to added to the original reosurce&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-request-ext.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-request-ext.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>How to read OpenStack code part 6 - core plugin and extension</title>
        <description>&lt;p&gt;本章我们将写一个自己的core plugin 和一个resource extension来加深理解。(阅读本文的前提是你已经理解了restful以及stevedore等内容)&lt;/p&gt;

&lt;h1 id=&quot;core-plugin&quot;&gt;什么是 core plugin&lt;/h1&gt;

&lt;p&gt;neutron的plugin有core和service两种。core plugin实现core resource的增删改查，service plugin我们在本文暂不讨论。&lt;/p&gt;

&lt;p&gt;core resource 有network/subnet/port/subnet-pool。每种资源对应CURD和index5种操作。以network资源为例，相关操作和HTTP请求的对应关系如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create_network    POST networks
delete_network    DELETE networks/network_id
update_network    PUT networks/network_id
get_network       GET networks/network_id
get_networks      GET networks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因此，core plugin中对各种核心资源都有如下的函数对应：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create_{resource_name}
update_{resource_name}
delete_{resource_name}
get_{resource_name}
get_{resource_names}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;how-to-write-core-plugin&quot;&gt;how to write core plugin&lt;/h1&gt;

&lt;p&gt;既然是plugin，也就是我们前面说过的third-party code，那就应该定义一些接口，好让第三方的组织可以参与开发。&lt;/p&gt;

&lt;p&gt;neutron中定义的接口在neutron.neutron_plugin_base_v2.NeutronPluginBaseV2。要实现一个core plugin，你需要实现这个class。&lt;/p&gt;

&lt;p&gt;下面是我写的一个core plugin 代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from neutron import neutron_plugin_base_v2
from oslo_log import log
LOG = log.getLogger(__name__)


class MyNeutronPlugin(neutron_plugin_base_v2.NeutronPluginBaseV2):
	supported_extension_aliases = ['gold']
	def __init__(self):
		super(MyNeutronPlugin,self).__init__()
	#### network ####
	def create_network(self, context, network):
		LOG.info(&quot;network is %s&quot; %network)
		return network
	def update_network(self, context, id, network):
		return network
	def get_network(self, context, id, fields=None):
		network = {}
		return network
	def get_networks(self, context, filters=None, fields=None):
		network = {}
		LOG.info(&quot;return network %s&quot; %network)
		return network
	def delete_network(self, context, id):
		return id
            ...
            #### gold ####
	def create_gold(self, context, gold):
		LOG.info(&quot;gold is %s&quot; %gold)
		return gold
	def update_gold(self, context, id, gold):
		return gold
	def get_gold(self, context, id, fields=None):
		gold = {}
		return gold
	def get_golds(self, context, filters=None, fields=None):
		gold = {}
		LOG.info(&quot;return gold %s&quot; %gold)
		return gold
	def delete_gold(self, context, id):
		return id
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请注意，除了network等核心资源，我们还实现了一个gold资源。 上面粘贴的内容省略了subnet/port/subnet-pool的相关代码。 既然是thirty-party code,就应该可以独立安装。所以我们的代码结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myPlugin/
├── myPluginPKG
│   ├── __init__.py
│   └── myPluginModule.py
└── setup.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;.py的内容为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import myPluginModule
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;setup.py内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from setuptools import setup, find_packages

setup(
	name='myPluginPKG',
	version='1.0',

	packages=find_packages(),

	entry_points={
		'neutron.core_plugins': [
			'myNeutronPlugin = myPluginPKG.myPluginModule:MyNeutronPlugin',
		],
	},
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样在运行python setup.py install 后，我们的plugin就注册到了neutron.core_plugins这个namespace下。这部分内容其实就是前面stevedore中driver开发的内容。neutron通过stevedore在这个namespace下加载core_plugin&lt;/p&gt;

&lt;p&gt;OK。在python setup.py install 后，我们的core plugin安装完成了，这时要修改/etc/neutron/neutron.conf，让neutron使用我们的core plugin。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[default]
core_plugin = myNeutronPlugin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后重启neutron服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl restart neutron-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来你就可以通过API 尝试了， 我们创建一个network 如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -g -i -X POST &quot;http://liberty-controller01:9696/v2.0/networks&quot; -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token:$token&quot; -d '{&quot;network&quot;: {&quot;name&quot;: &quot;n2&quot;, &quot;admin_state_up&quot;: true}}'
HTTP/1.1 201 Created
Content-Type: application/json; charset=UTF-8
Content-Length: 15
X-Openstack-Request-Id: req-a8cfde05-6425-42fe-b516-0bb2d264cf61
Date: Tue, 07 Feb 2017 08:01:47 GMT

    {&quot;network&quot;: {}}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到成功返回，因为我们的plugin中什么也没做，所以返回的其实是一个空的字典。但至少证明该api成功了。&lt;/p&gt;

&lt;p&gt;之前我们还在plugin中增加了gold资源对应的函数，我们试试访问gold资源：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -g -i  &quot;http://liberty-controller01:9696/v2.0/golds&quot; -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token:$token&quot; 
HTTP/1.1 404 NOT FOUND
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为什么gold资源的API不好使呢。这是因为要想在neutron core plugin中定义一个资源，不仅要提供该资源的CURD 函数，还要有对应的RESOURCE_ATTRIBUTE_MAP.&lt;/p&gt;

&lt;h1 id=&quot;resourceattributemap&quot;&gt;RESOURCE_ATTRIBUTE_MAP&lt;/h1&gt;

&lt;p&gt;RESOURCE_ATTRIBUTE_MAP是neutron/api/v2/attribute.py中的一个字典，其结构大概如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RESOURCE_ATTRIBUTE_MAP = {
	NETWORKS: {
		'id': {'allow_post': False, 'allow_put': False,
			   'validate': {'type:uuid': None},
			   'is_visible': True,
			   'primary_key': True},
		'name': {'allow_post': True, 'allow_put': True,
				 'validate': {'type:string': NAME_MAX_LEN},
				 'default': '', 'is_visible': True},
		'subnets': {'allow_post': False, 'allow_put': False,
					'default': [],
					'is_visible': True},
		'admin_state_up': {'allow_post': True, 'allow_put': True,
						   'default': True,
						   'convert_to': convert_to_boolean,
						   'is_visible': True},
		'status': {'allow_post': False, 'allow_put': False,
				   'is_visible': True},
		'tenant_id': {'allow_post': True, 'allow_put': False,
					  'validate': {'type:string': TENANT_ID_MAX_LEN},
					  'required_by_policy': True,
					  'is_visible': True},
		SHARED: {'allow_post': True,
				 'allow_put': True,
				 'default': False,
				 'convert_to': convert_to_boolean,
				 'is_visible': True,
				 'required_by_policy': True,
				 'enforce_policy': True},
	},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该字典定义了资源以及资源对应的属性，我们这里只列出了network。所以，要想定义gold资源，除了在core plugin中添加对应的函数，还有在这个attribute map中添加相关的信息。不过，我们不建议直接修改这里的代码，正确的方法是通过resource extension来实现。&lt;/p&gt;

&lt;h1 id=&quot;how-to-code-an-extension-resource-extension&quot;&gt;how to code an extension (resource extension)&lt;/h1&gt;

&lt;p&gt;之前提到了extension有3种类型，resource，action，request。我们这里要实现一个新的资源，就是用resource extension。无论是哪种extension 都要遵守一些特定的规则，或者说接口，这些规则如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. extension应该放在neutron/extensions文件夹下，或者在配置文件中设置api_extensions_path
2. extension的class名应该和文件同名，当然首字母应该大写
3. 应该实现neutron.api.extensions.py中ExtensionDescriptor定义的接口
4. 在对应的plugin的supported_extension_aliases 中增加我们extension的别名。前面我们写的core plugin就有这个属性，当时没有做说明，其实是这里应该添加的。所谓别名是该extension要实现的一个接口，后面会看到。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外很重要的一点是，因为我们要实现的是resource extension，所以还要实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;get_resources 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个接口。&lt;/p&gt;

&lt;p&gt;下面我们实现一个自己的resource extension来增加 gold 资源。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from neutron.api import extensions
from neutron import manager
from neutron.api.v2 import base

# You have to specify the attributes neutron-server should expect when
# someone invokes this plugin. Let's say you want
# 'name', 'priority', 'credential' for your extension /golds
# then following dictionary must be declared.
# I am following the naming convention used by other extensions.

RESOURCE_ATTRIBUTE_MAP = {
	'golds': {
	'name': {'allow_post': True, 'allow_put': True,
				 'is_visible': True},
	'priority': {'allow_post': True, 'allow_put': True,
				 'is_visible': True},
	'credential': {'allow_post': True, 'allow_put': True,
				 'is_visible': True},
	# tenant_id is the user id used by keystone for authorisation
	# It's good to use the following as it is and it is necessary
	# for every extension 
	'tenant_id': {'allow_post': True, 'allow_put': False,
				  'required_by_policy': True,
				  'validate': {'type:string': None},
				  'is_visible': True}
	}
}

# Great! Now you have the defined the attributes that you need for your
# extensions. You need to store this dictionary in the neutron-server
# by the following class

class Golds(extensions.ExtensionDescriptor):
	# The name of this class should be the same as the file name
	# There are a couple of methods and their properties defined in the
	# parent class of this class, ExtensionDescriptor you can check them

	@classmethod
	def get_name(cls):
		# You can coin a name for this extension
		return &quot;Name of golds&quot;

	@classmethod
	def get_alias(cls):
		# This alias will be used by your core_plugin class to load
		# the extension
		return &quot;gold&quot;

	@classmethod
	def get_description(cls):
		# A small description about this extension
		return &quot;A quick brown fox jumped over a lazy dog&quot;

	@classmethod
	def get_namespace(cls):
		# The XML namespace for this extension
		# but as we move on to use JSON over XML based request
		# this is not that important, correct me if I am wrong.
		return &quot;namespace of xml&quot;

	@classmethod
	def get_updated(cls):
		# Specify when was this extension last updated,
		# good for management when there are changes in the design
		return &quot;2017-02-07T10:00:00-00:00&quot;

	@classmethod
	def get_resources(cls):
		# This method registers the URL and the dictionary  of
		# attributes on the neutron-server.
		exts = list()
		plugin = manager.NeutronManager.get_plugin()
		resource_name = 'gold'
		collection_name = resource_name + 's'
		params = RESOURCE_ATTRIBUTE_MAP.get(resource_name + 's', dict())
		controller = base.create_resource(collection_name, resource_name,
										  plugin, params, allow_bulk=False)
		ex = extensions.ResourceExtension(collection_name, controller)
		exts.append(ex)

		return exts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码的大部分解释都包含在注释里，因此请详细阅读每一行。这里只重点说一下RESOURCE_ATTRIBUTE_MAP 和 get_resources。 我们的extension就是通过这个函数来在resource attribute map中增加了gold资源。
另外要注意的是get_alias，该函数返回extension的别名，plugin的supported_extension_alias中用该别名来找extension。&lt;/p&gt;

&lt;p&gt;ok，我们现在尝试一下访问gold 资源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -g -i http://liberty-controller01:9696/v2.0/golds.json -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token:$token&quot;
HTTP/1.1 200 OK
Content-Type: application/json; charset=UTF-8
Content-Length: 13
X-Openstack-Request-Id: req-7b925f97-4df0-49ee-bb6a-fd7c86fda9aa
Date: Tue, 07 Feb 2017 08:29:34 GMT

{&quot;golds&quot;: []}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次成功了。 以上就是core plugin和resource extension&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Jul 2017 16:43:59 +0800</pubDate>
        <link>http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-plugin.html</link>
        <guid isPermaLink="true">http://ciscochina.github.io/engineering/openstack/2017/07/12/openstack-plugin.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
  </channel>
</rss>
